# length-of-last-word 2024-07-21

**最原始的代码**

```javascript
/*
 * @lc app=leetcode id=70 lang=javascript
 *
 * [70] Climbing Stairs
 */

// @lc code=start
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    if(n<=3){
        return n;
    }
    else{
        return climbStairs(n-1)+climbStairs(n-2);
    }
};
// @lc code=end


```

**代码评估**
递归思路没有问题，但在提交的时候出现了超时

**改进第一版代码**

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    if (n <= 2) return n;
    
    let dp = new Array(n + 1);
    dp[1] = 1;
    dp[2] = 2;
    
    for (let i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
};

```
**代码评估**
代码超时的原因是因为使用了递归，在处理较大的输入时效率较低。
具体来说，递归方法可能会导致重复计算许多子问题。

**详细解释**
  -  递归计算的重复性：
    climbStairs(n) 会调用 climbStairs(n-1) 和 climbStairs(n-2)。
    例如，计算 climbStairs(4) 会同时计算 climbStairs(3) 和 climbStairs(2)，
    而 climbStairs(3) 又会计算 climbStairs(2) 和 climbStairs(1)，
    这样 climbStairs(2) 和 climbStairs(1) 被多次重复计算。
 -  指数级别的计算量：
    递归的时间复杂度是指数级的，因为每个 n 的计算都依赖于两个更小的子问题，而每个子问题又会产生更多的子问题。这会导致大量的重复计算，特别是对于较大的 n 值。

**优化方法**
    使用动态规划（DP）可以显著提高效率。动态规划通过存储已经计算过的结果，避免了重复计算，从而提高了算法的时间效率。
    创建一个数组 dp，其中 dp[i] 存储从第 i 阶梯到达顶部的方法数。
    根据状态转移方程 dp[i] = dp[i - 1] + dp[i - 2] 来填充数组。这样可以通过一次遍历来计算结果，从而将时间复杂度降低到O(n)。

**总结**
递归方法会导致超时是因为它的计算量随着输入的增大而指数级增长。
通过动态规划，可以将问题转化为线性计算，从而提高效率，避免超时。

**改进第二版代码**
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    if (n <= 3) return n;
    
    let pre1 = 3;
    let pre2 = 2;
    let current;
    
    for (let i = 3; i < n; i++) {
        current = pre1 + pre2;
        pre2 = pre1;
        pre1 = current;
    }

    return current;
};

```


**代码评估**
空间复杂度降低到了O(1)