# 2024-07-27

**最原始的代码**

```javascript
/*
 * @lc app=leetcode id=119 lang=javascript
 *
 * [119] Pascal's Triangle II
 */

// @lc code=start
/**
 * @param {number} rowIndex
 * @return {number[]}
 */
var getRow = function (rowIndex) {
	let result = [];
	[result[0], result[rowIndex]] = [1, 1];
	// 计算前一半 递归 后一半对称
	// rowIndex = 0 return [1]
	// rowIndex = 1 return [1, 1]
	// rowIndex = 2 return [1, 2, 1] half 1
	// rowIndex = 3 return [1, 3, 3, 1] half 1
	// rowIndex = 4 return [1, 4, 6, 4, 1] half 2
	// rowIndex = 5 return [1, 5, 10, 10, 5, 1] half 2
	// rowIndex = 6 return [1, 6, 15, 20, 15, 6, 1] half 3
	for (let i = 1; i <= Math.floor(rowIndex / 2); i++) {
		result[i] = (result[i - 1] * (rowIndex - (i - 1))) / i;
	}
	for (let i = 1 + Math.floor(rowIndex / 2); i < rowIndex; i++) {
		result[i] = result[rowIndex - i];
	}
	return result;
};
// @lc code=end
```

**leetcode solution**

```javascript
/**
 * @param {number} rowIndex
 * @return {number[]}
 */
var getRow = function (rowIndex) {
	let row = [1];

	for (let i = 0; i < rowIndex; i++) {
		row = row.map((val, index) => (row[index - 1] || 0) + (row[index] || 0));
		row.push(1);
	}

	return row;
};
```

**代码评估**

-   这个循环从 0 开始，迭代 rowIndex 次，以生成指定的行。
-   使用 map 函数来遍历当前行 row，并计算新行的每个元素。
-   row[index - 1] || 0 表示当前元素的左侧元素，如果不存在则为 0。
-   row[index] || 0 表示当前元素，如果不存在则为 0。
-   计算新行时，将当前元素和左侧元素相加，得到新行中的对应元素。

# 2024-09-21 二刷

```js
const getRow = rowIndex => {
	const array = new Array(rowIndex + 1).fill(0).map((value, index) => new Array(index + 1).fill(1));
	for (let row = 2; row < rowIndex + 1; row++) {
		for (let index = 1; index < row; index++) {
			array[row][index] = array[row - 1][index - 1] + array[row - 1][index];
		}
	}
	return array[rowIndex];
};
```
