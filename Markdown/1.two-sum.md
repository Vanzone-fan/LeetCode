# two-sum 2024-07-12

**最原始的代码**

```javascript
/*
 * @lc app=leetcode id=1 lang=javascript
 *
 * [1] Two Sum
 */

// @lc code=start
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */

var twoSum = function(nums, target) {
    nums.forEach(element => {
        if(nums.includes(target-element)){
            var indexA = nums.findIndex(target);
            var indexB = nums.findIndex(target-element);
        }
    });
    return indexA,indexB;
};

// @lc code=end
function([2,7,11,15],9)
```

**出现的问题**

- 一些细节问题
  - 需要返回的是一个数组
  - 函数没有命名
  - return 只能返回一个值。如果用逗号隔开多个值，则以最后一个为准
- 对函数使用意义不明确
  - findIndex() 参数是一个表达式，满足表达式的返回index否则-1
  - includes() 参数是元素，返回boolean
  - indexOf() 参数是元素，返回第一次出现的index否则-1
- 没有考虑到特殊情况
  - 当当前项的二倍是target，返回的是两个一样的数字，即为当前的index
  - 当数组存在重复的元素，如[3,3,4],6，需要对重复元素进行审查

**改进第一版代码**

```javascript
/*
 * @lc app=leetcode id=1 lang=javascript
 *
 * [1] Two Sum
 */

// @lc code=start
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    var res = [];
    nums.forEach(element => {
        if(nums.includes(target-element)){
            const index1 = nums.indexOf(element);
            const index2 = nums.indexOf(target-element);
            if(index1!=index2 && !res.includes(index1) && !res.includes(index2)){
                res.push(index1);
                res.push(index2);
            }

        }
    });
    return res;
};
// @lc code=end
```

**过程中遇到的问题**

- 针对单个元素不重复出现但是导致的index一样的特殊情况，比如[3,2,4],6为参数的函数调用。只需要在if判断时添加不相等判定语句
- 但是这个方案呢，无法解决重复元素数组问题，因为indexOf判断一个元素第一次出现的位置，index1和index2此时肯定还是一样的，比如【3,3】,6。
  
**改进第二版代码**

```javascript
/*
 * @lc app=leetcode id=1 lang=javascript
 *
 * [1] Two Sum
 */

// @lc code=start
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function (nums, target) {
    var res = [];
    var sumMap = new Map();

    nums.forEach((element, index) => {
        const complement = target - element;
        if(sumMap.has(complement)){
            const complementIndex = sumMap.get(complement);
            if(complementIndex !== index){
                res.push(index,complementIndex);
            }
        }
        sumMap.set(element,index);
    });
    return res;
};
// @lc code=end
```

**改进优势**

- 使用Map查找提高效率
- 需要多反应index部分是如何处理重复元素的，这部分逻辑很神奇
- 抛却了最初代码中再循环内部计算表达式的低效率做法

**复杂度分析**

- 第一版代码调用的函数都是O(n),在forEach函数内部有includes和indexOf方法，所以复杂度是O(n<sup>2</sup>)
- 第二版代码只在map内部操作，所有的都基于map元素遍历，时间复杂度是O(n)
