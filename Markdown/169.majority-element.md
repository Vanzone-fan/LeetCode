<!--
 * @Author: github Vanzone-fan github fanzong889@gmail.com
 * @Date: 2024-07-27 22:31:46
 * @LastEditors: github Vanzone-fan github fanzong889@gmail.com
 * @LastEditTime: 2024-07-27 22:49:20
 * @FilePath: \LeetCode\Markdown\169.majority-element.md
 * @Description: 
 * 
 * Copyright (c) 2024 by ${git_name_email}, All Rights Reserved. 
-->
# majority-element 2024-07-27
**最原始的代码**
```javascript
/*
 * @lc app=leetcode id=169 lang=javascript
 *
 * [169] Majority Element
 */

// @lc code=start
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function (nums) {
    let count = 0;
    countArr = [];
    nums.forEach((num) => {
        countArr[num] += 1;
    });
    countArr.forEach((num) => {
        if (num > Math.floor(nums.length / 2)) {
            return num;
        }
    });
    return -1;
};
// @lc code=end
```

**代码评估**
- 这个代码的逻辑很简单，遍历数组 nums，并将每个元素的出现次数存储在 countArr 中。
- 问题出在
  - num第一次是undefined，导致countArr[num] += 1报错。    

**第一次改进代码**
```javascript
/*
 * @lc app=leetcode id=169 lang=javascript
 *
 * [169] Majority Element
 */

// @lc code=start
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function (nums) {
    let majority = -1;
    let count = 0;
    // find max in nums
    let max = nums[0];
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] > max) {
            max = nums[i];
        }
    }
    // init countArr with 0
    countArr = new Array(max + 1).fill(0);
    nums.forEach((num) => {
        countArr[num] += 1;
    });

    countArr.forEach((num) => {
        if (num > Math.floor(nums.length / 2)) {
            majority = countArr.indexOf(num);
        }
    });
    return majority
};
// @lc code=end
majorityElement([3,2,3])
console.log('majorityElement([3,2,3]): ', majorityElement([3,2,3]));
```


**代码评估**

- 我感觉这是一个很low的想法，用开辟新数组去存放 countArr 并不是一个好主意。（虽然这么做是可以达到目的的，如果数字很小的话。）
- 正如我之前所说，一旦开启数字大的噩梦处理，对时间和空间的要求必然都是很高的。
- 在改进过程中，我是这试forEach函数的半途去返回一个最终的结果，但其实这个return并没有定义在结果函数上，导致最后返回的结果写在forEach函数内部，submit的其实都是undefined。为此，只能再次借助一个临时变量majority去记录最终返回的结果。
- 当然，目前只剩下了如何处理时间空间占用的问题，不然在面对数组内部数字传入过大时是难以解决的。

**leetcode solution**
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    let candidate = 0;
    let count = 0;
    
    // Boyer-Moore Voting Algorithm
    for (const num of nums) {
        if (count === 0) {
            candidate = num;
            count = 1;
        } else if (candidate === num) {
            count++;
        } else {
            count--;
        }
    }
    
    // Return the candidate (the algorithm assumes there is always a majority element)
    return candidate;
};
```
**代码评估**
- Boyer-Moore Voting Algorithm 是一个很有趣的算法，它通过比较数组中元素的个数来判断是否存在众数。
- 算法的思路是，如果当前元素与候选元素相同，则计数器加一；如果不同，则计数器减一。当计数器为零时，更新候选元素为当前元素。
- 算法的时间复杂度为 O(n)，空间复杂度为 O(1)。
- 算法的正确性依赖于数组中元素的分布，如果元素分布不均匀，则算法可能无法正确判断众数。